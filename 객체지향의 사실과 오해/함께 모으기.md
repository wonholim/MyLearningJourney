# 함께 모으기

- [x] 1. 커피 전문점 도메인
- [x] 2. 설계하고 구현하기
- [x] 3. 코드와 세 가지 관점

(완벽하게 책의 내용을 담은게 아닙니다. 책을 읽고 요약을 중심으로 작성했습니다. 정확한 이해를 위해선 책을 구매해 직접 읽어야 합니다.)

<br><br>

## 1. 커피 전문점 도메인

---

<br>

 `마틴 파울러는 객체지향 설계 안에 세 가지 관점을 각각 개념 관점, 명세 관점, 구현 관점이라 부른다.`

 `개념 관점에서 설계는 도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다. 실제 도메인의 규칙과 제약을 최대한 유사하게 반영하는 것이 핵심이다.`

 `명세 관점은 객체의 인터페이스를 바라보게 되며, 객체가 협력을 위해 무엇을 할 수 있는가에 초점을 맞춘다. (인터페이스)`

 `구현 관점은 객체들이 책임을 수행하는 데 필요한 동작하는 코드를 작성하는 것이다. 객체의 책임을 어떻게 수행할 것인가에 초점을 맞추며 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가한다.`

 개념 관점, 명세 관점, 구현 관점은 동일한 클래스를 세 가지 다른 방향에서 바라보는 것을 의미하며, 클래스는 세 가지 관점을 모두 수용할 수 있도록, 개념, 인터페이스, 구현을 하께 드러내며 쉽게 식별할 수 있도록 깔끔하게 분리해야 한다.

 카페에선 메뉴판과 메뉴판 안에 항목들이 존재한다. 각각을 객체로서 이해할 때, 멘판 객체는 다수의 메뉴 항목 객체로 구성되어 있다. 즉 **Composition 관계**를 나타낸다. 

`메뉴판 🔸-- 메뉴항목`

 손님은 메뉴판 타입을 알아야 메뉴 항목을 선택할 수 있다. 이 처럼 한 타입의 인스턴스가 다른 타입의 인스턴스를 포함하지는 않지만 서로 알고 있어야 할 경우, **Association 관계**라 한다.

```text
메뉴판 🔸-- 메뉴항목
 |
 |
손님
```

 바리스타는 커피를 제조해야 하므로, 커피를 알아야 하며, 메뉴판과 커피 중 어떤 것도 바리스타의 일부가 아니므로 Association 관계이다.

```text
  메뉴판 🔸-- 메뉴항목
   |
   |
  손님
   |
   |
 바리스타--커피
```

 `실제로 도메인 모델을 작서하는 단계에서 어떤 관계가 포함 관계이고 어떤 관계가 연관 관계인지는 중요하지 않다. 초점은 어떤 타입이 도메인을 구성하느냐와 타입들 사이에 어떤 관계가 존재하는지를 파악함으로써 도메인을 이해하는 것이다.`

<br><br>

## 2. 설계하고 구현하기

---

<br>

 객체지향 설계의 첫 번째 목표는 훌륭한 객체를 설계하는 것이 아닌, 훌륭한 협력을 설계하는 것이다. 협력을 설계할 때에는 객체가 메시지를 선택하는게 아닌 메시지가 객체를 선택하게 해야 한다. 

```text
협력을 위한 첫 번쨰 메시지

 메뉴 이름
 o---->
 커피를 주문하라
 ---------->
```

 메시지 위에 붙은 화살표는 메시지에 담아 전달될 부가적인 정보인 **인지**를 의미한다.

 이제 은유를 시작해 보자. 도메인 모델을 중심으로 은유를 보면, 커피를 주문하라라는 메시지를 처리할 객체는 누구인가? 바로 손님이다.

```text
 메뉴 이름
 o---->
 커피를 주문하라
 ---------->손님
```

 손님 객체는 커피를 주문할 책임을 할당 받았다. 손님이 커피를 주문하는 도중에 스스로 할 수 없는 일이 무엇인지 생각해 보자. 손님이 할당된 책임을 수행하는 도중에 스스로 할 수 없는 일이 있다면, 다른 객체에게 요청해야 한다. 이 요청이 바로 손님 객체에서 외부로 전송되는 메시지를 정의한다.

```text
스스로 할 수 없는 일은 메시지를 전송해 다른 객체에게 도움을 요청한다.

 메뉴 이름          메뉴 이름 
 o---->           o---->
 커피를 주문하라     메뉴 항목을 찾아라
 ----------> 손님 ------------>
                      <----o
                      메뉴 항목
```

 이 경우 메시지에 메뉴 이름이라는 인자를 포함해 함께 전송한다. 그리고 메뉴 항목을 찾아라라는 메시지를 수신한 객체는 메뉴 이름에 대응되는 메뉴 항목을 반환해야 한다.

 그러면 메뉴 항목을 찾을 책임을 누구에게 할당하는게 좋을까? 메뉴를 잘알고있는 객체인 메뉴판에게 할당하는게 가장 적절한 후보다.

```text
 메뉴 이름          메뉴 이름 
 o---->           o---->
 커피를 주문하라     메뉴 항목을 찾아라
 ----------> 손님 ------------> 메뉴판
                      <----o
                      메뉴 항목
```

 이제 손님은 메뉴를 찾았으니, 커피를 제조해 달라고 요청할 수 있다.

```text
        메뉴 항목 
        o---->
      커피를 제조 하라
 손님 ------------> 바리스타
        <----o
          커피
```

 그리고, 바리스타는 커피를 만들기 위한 모든 정보를 다 알고 있다.

```text
        메뉴 항목 
        o---->
      커피를 제조 하라          생성하라
 손님 ------------> 바리스타 ----------> 커피
        <----o
          커피
```

 `객체가 수신한 메시지가 객체의 인터페이스를 결정한다는 사실을 기억하자, 메시지가 객체를 선택했고, 선택된 객체는 메시지를 자신의 인터페이스로 받아들인다.`

```text
각각의 인터페이스

      메뉴 이름 
       o---->           
     커피를 주문하라 
    -------------> 손님 

        메뉴 이름
        o---->
    메뉴 항목을 찾아라
    -------------> 메뉴판
        <----o
        메뉴 항목

        메뉴 항목 
        o---->
      커피를 제조 하라
    -------------> 바리스타
        <----o
          커피

        생성하라
    -------------> 커피
```

</br></br>

## 3. 코드와 세 가지 관점

---

</br>

 개념 관점에선, Customer, Menu, MenuItem, Barista, Coffee 클래스가 보이며 이는 커피 도메인을 구성하는 중요한 개념과 관계를 반영함을 알 수 있다. 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지보수성을 향상시킬 수 있다.

 명세 관점에선 클래스의 인터페이스를 바라본다. 클래스의 public 메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 들어낸다. 공용 인터페이스는 외부의 객체가 해당 객체에 접근할 수 있는 유일한 부분이며, 인터페이스를 수정하면 해당 객체와 협력하는 모든 객체에게 영향을 미칠 수 밖에 없다. 객체의 인터페이스는 수정하기 어렵고, 최대한 변화에 안정적인 인터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야한다.

 구현 관점은 클래스의 내부 구현을 바라본다. 클래스의 메서드와 속성은 구현에 속하며 공용 인터페이스의 일부가 아니다. 따라서 메서드의 구현과 속성의 변경은 원칙적으로 외부 객체에게 영향을 미쳐서는 안된다.

 `인터페이스와 구현을 분리하라, 인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이 요동치는 취약한 설계를 얻을 수밖에 없다.`

</br></br>
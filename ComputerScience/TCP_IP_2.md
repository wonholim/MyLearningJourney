# TCP/IP_2

- [x] 캡슐화와 역캡슐화
- [x] 데이터 통신을 처리하는 과정
  - [x] 아파치서버와의 HTTP 통신
  - [x] 응용 계층
  - [x] 전송 계층
  - [x] 인터넷 계층
  - [x] 네트워크 인터페이스 계층
- [x] 참고 자료

---

<br/><br/>

## 캡슐화와 역캡슐화

---

<br/>

- 패킷은 네트워크를 통해 전송되는 기본 정보 단위로, 기본 패킷은 송신 및 수신 시스템의 주소가 있는 헤더, 본문 또는 전송될 데이터가 있는 **페이로드**(데이터 통신에서 전송되는 실제 사용자 데이터)로 구성이된다.
- 패캣의 구조는 `헤더`, `페이로드`, `트레일러`로 구성이 된다.
  - `헤더` : 패킷의 전송에 필요한 제어 정보를 나타낸다. (출발지와 목적지 주소, 프로토콜의 정보)
  - `페이로드` : 실제 전송되는 데이터의 내용
  - `트레일러` : 오류 검출 및 교정을 위한 정보

![image](https://user-images.githubusercontent.com/56383948/261204994-d38ac808-31ea-4786-9ac4-8d0cc6adc57f.png)

<br/>

- 패킷은 TCP/IP 프로토콜 스택을 통해서, 이동을 할 때 각 계층의 프로토콜을 기본 헤더에서 필드를 추가하거나 제거한다.
- `캡슐화`는 송신자의 프로토콜이 패킷 헤더에 데이터를 추가하게되면 이 과정을 데이터 캡슐화라고 한다.
- `역캡슐화`는 수신자의 각 프로토콜이 송신자의 해당 피어로 패킷에 연결된 헤더 정보를 제거하는 것을 데이터 역캡슐화라고 한다.

- 각 계층마다 `캡슐화`하여 패킷이 변경될 때 서로 다른 용어를 사용하게 된다.
  - `응용 계층의 캡슐화` : 해당 계층의 패킷의 용어는 **메시지**로 불린다.
  - `전송 계층의 캡슐화` : 해당 계층의 패킷의 용어는 **세그먼트**로 불린다.
  - `인터넷 계층의 캡슐화` : 해당 계층의 패킷의 용어는 **데이터그램**으로 불린다.
  - `네트워크 인터페이스 계층의 캡슐화` : 해당 계층의 패킷의 용어는 **프레임**으로 불린다.

- 패킷의 수명 주기는 송신자가 전송을 시작할 때, 수명 주기가 시작이 되고, 수신자가 응용 계층에서 패킷을 수신할 때 수명 주기가 끝나게된다.

<br/>

## 데이터 통신을 처리하는 과정

---

<br/>

- 브라우저에서 `naver.com`을 입력하면 발생하는 흐름을 살펴본다.
- WireShark와 Chrome Dev Tool을 이용한다.

- 네이버의 주소
  - 네이버는 DNS가 `naver.com`이다.

<img width="971" alt="image" src="https://user-images.githubusercontent.com/56383948/261222280-ca5c7425-a775-4f41-b427-45044ed79544.png">

<br/>

- IP 주소는 `223.130.195.95`이고, Port는 `443`이다.
  - 포트번호에서 `80`은 http를 의미하고, `443`은 https를 의미한다.
  <img width="536" alt="image" src="https://user-images.githubusercontent.com/56383948/261222666-e26e7b9d-5bc8-494e-a958-9bbd59fa6842.png">

<br/>

- 어째서, http요청 80이 아닌, https 443으로 지정이 되었을까?
- 사실 브라우저는 HSTS리스트를 순회하며, 도메인이 리스트에 포함되어있는지 확인한다.
- 만약 HSTS에 포함이 된다면, https 443요청을 시도하며, 없는 경우 http 80요청을 한다.
- 크롬 개발자 도구에서 네트워크 응답 헤더에 보면 HSTS를 직접 볼 수 있다.
  <img width="738" alt="image" src="https://user-images.githubusercontent.com/56383948/261224074-6834dd58-3972-4557-ac27-e1d9ef77c12c.png">

- 이외에도 `chrome://net-internals/#hsts`, [HTST리스트JSON](https://source.chromium.org/chromium/chromium/src/+/main:net/http/transport_security_state_static.json)을 통해 더 자세하게 알아볼 수 있다.

<br/>

- `naver.com`을 쳤을 때, 시작점 주소가 `pm.pstatic.net`으로 다르다는 것을 볼 수 있다.
  <img width="771" alt="image" src="https://user-images.githubusercontent.com/56383948/261225864-8eec1e4d-a18b-4ba9-ac6c-edcc09608869.png">

<br/>

- 실제로 `pm.pstatic.net`을 브라우저에 입력하고 엔터를 누른다면, 같은 네이버 화면이 뜨는 것을 알 수 있다.
- `pm.pstatic.net`에서 시작해서, 다른 곧에 요청을 보내는 것을 알 수 있다.
  <img width="771" alt="image" src="https://user-images.githubusercontent.com/56383948/261227937-624af1d0-9b4a-40ac-8c4f-5a3377855763.png">

<br/>

- 네이버를 통해, 통신 과정을 보려고 했지만, 생각보다 복잡해서, 아마존에 아파치 서버를 깔고, 테스트를 진행한다.

<br/>

### 아파치서버와의 HTTP 통신

<br/>

![image](https://user-images.githubusercontent.com/56383948/261842653-fa64f1cb-de54-435a-8721-2f18dda1aaa5.png)

- 아마존에 서버를 올려서, 실제로 HTTP 통신을 하는 과정을 살펴보면 GET 요청을 하기전, 연결을 확인하기 위해, 3-way-handshake 과정을 거친다.
- TCP 연결이 확립된 이후, GET 요청을 한다.
- 서버는 클라이언트의 요청을 성공적으로 받았음을 의미하는 ACK를 응답한다.
- PSH 플래그의 경우, TCP 버퍼에 있는 데이터를 상대방에게 즉시 전달하도록 지시하며, 데이터를 즉각 처리해야하는 상황에서 사용한다.
- 서버는 요청에 클라이언트에게 반응을 보낸다.
- 이후, 서버는 클라이언트와 다시 핸드 셰이크 과정을 거친다.
- 서로 통신을 완료했기 떄문에, 4-way-handshake 과정을 거쳐서, TCP 연결을 안전하게 종료한다.
- 종료의 주체가 서버이므로 서버는 클라이언트에게 FIN을 보내고, 클라이언트는 이에 응답해서 ACK, FIN을 보내게 된다.
- 마지막으로 서버는 클라이언트에게 ACK를 보내면서 마무리한다.

- 그렇다면, HTTP 요청을 각 계층 단위로 살펴본다.

<br/>

### 응용 계층

<br/>

![image](https://user-images.githubusercontent.com/56383948/261843319-5ff7477a-3434-417e-bc6a-0c3662516d35.png)

- HTTP 프로토콜은 응용 계층에서 사용하는 프로토콜로, 서버에게 GET 요청을 보냈을 때의 패킷을 캡쳐한 것이다.
- `host` : 요청하는 호스트에 대한 정보를 가진다. (서버의 IP를 가지고 있다.)
- `User-Agent` : 클라이언트가 서버에게 요청할 때 사용한 브라우저가 담겨있다. (사파리를 사용했다.)
- `Accept` : 클라이언트가 해석 가능한 타입을 지정한다. 서버는 Accept의 형식을 보고, 응답을 구성할 때 클라이언트가 처리가능한 형식으로 보내야함을 알려주는것이다.
  - Accept: text/html, application/xhtml+xml, application/xml;q=0.9, image/webp, */*;q=0.8 와 같이 구성이 되어있음을 볼 수 있는데, q=0.9, q=0.8의 경우 각 미디어 타입의 우선 순위를 의미한다. 0과 1사이의 값으로 표현한다.
  - 만약 Accept 헤더에 포함된 타입으로 응답할 수 없는 경우, 406 에러를 응답으로 보내게된다.
- `connection` : HTTP 프로토콜의 경우, 연결을 유지하지않고, 보내고 끊고 받고 끊고 새로 연결하므로, Keep-Alive를 설정해 만약 일정 시간동안 요청과 접속이 없더라도 연결을 끊지 않고 유지하는 것을 의미한다.
  - HTTP 1.1 부터는 기본적으로 Keep-alive가 활성화 되어있다.
  - close로 설정한 경우, 연결을 한 후, 끊겠다는 의미이다. 네트워크를 효율적으로 관리하려면, close를 이용하면 될거같다.
- `\r\n` : HTTP에 사용되는 것으로 CRLF로 구성이 되어있다. 각 라인은 키-값으로 구성이되며, 라인의 끝은 CRLF로 구분짓는다.


<br/>

### 전송 계층

<br/>

![image](https://user-images.githubusercontent.com/56383948/261843935-3e322123-a1b8-49ad-b41e-bd068cb8161d.png)
![image](https://user-images.githubusercontent.com/56383948/261843967-ba6049e6-0596-4829-8dc1-8aefa4b5e8fd.png)

- 전송 계층은 OSI 7계층에서 4번째 계층이며, 애플리케이션 간에 정확한 데이터 전달을 보장하기 위해, 사용할 프로토콜, 포트 번호, 세그멘테이션과 재조립을 한다.
- `Source Port` : 출발지의 포트 번호로, 클라이언트와 서버가 연결되기 위해 사용하는 포트이다.
- `Destination Port` : 목적지 포트 번호로, 각 프로토콜 마다 사용되는 포트가 다르다.
- `Stream index` : 해당 스트림의 인덱스 번호이다. TCP의 경우 세션을 열고 유지하는데, 각 세션이 여러개 생길 수 있기 때문에, 구분하기 위한 식별자이다. (패킷 캡처 도구로, 특정 패킷에 대해 살펴볼 수 있다.)
- `Sequence Number` : TCP는 데이터의 순서가 보장이 되므로, 순서를 제어할 때 사용된다.
- `Acknowledgment Number` : 상대방이 받아야 할 다음 번호이다.
- `Flags` : TCP의 플래그로, 각 플래그를 설정할 수 있다. 현재 PSH, ACK 플래그가 설정되어있다.
- `Window` : 수신자가 한 번에 받을 수 있는 데이터양을 의미한다.
- `Checksum` : 세그먼트의 무결성을 검사하는데 사용되는 체크섬 값이다.
- `Urgent Pointer` : 긴급 포인터로 특정 데이터가 긴급하게 처리할 경우, 사용된다.
- `TCP payload` : 세그먼트에 실려 있는 실제 데이터의 크기이다.

<br/>

### 인터넷 계층

<br/>

![image](https://user-images.githubusercontent.com/56383948/261844695-cac69c9c-e8c1-4874-8a71-d620c0875f65.png)


- TCP/IP의 3번째 계층으로, `라우팅`, `프래그맨테이션과 재조립`, `오류 처리`, `TTL 처리`, `패킷 캡슐화`, `멀티캐스팅`을 한다.
- `Version` : IP 프로토콜의 버전을 나타낸다. Version 4의 경우 IPv4이다.
- `Identification` : 각 프래그먼트를 원래 데이터 그램과 일치시는 데 사용되는 식별자이다.
- `Flags` : 패킷 분할에 대해 어떻게 할지 정하는 필드로, 첫번째 bit는 0이다. 두번째의 경우가 1이면, 패킷을 조각화 하지않는다. More fragments가 0인 경우, 없으며, 1인 경우 추가적으로 더 있다는 것을 의미한다.
- `Time to Live` : 패킷의 생존 시간을 나타내며, 각 라우터를 지날 때 마다 1씩 감소한다. 0이되면 패킷은 폐기된다.
- `Protocol` : 다음 상위계층의 프로토콜이 어떤 것인지 나타낸다. 즉, 패킷은 상위 계층의 프로토콜을 포함시켜서 전송하므로, 어떤 프로토콜인지 알 수 있다.
- `Header Checksum` : 헤더의 오류 검사를 위한 체크섬 값이다.
- `Source Address` : 출발지의 IP 주소이다.
- `Destination Address` : 도착지의 IP주소이다.

<br/>

### 네트워크 인터페이스 계층

<br/>

- 프레임은 OSI 7계층에서 데이터 링크계층이다. 프레임이라는 구조를 사용해서, 패킷을 캡슐화하고 오류 검사, 순서 제어를 수행한다.
- TCP/IP에서는 네트워크 인터페이스 계층에 속한다. 데이터 링크를 통한 프레임의 전송 및 수신, 오류 검사, 순서 제어를 한다. MAC 주소를 이용해서 로컬 네트워크 내에서 통신을 한다. 예를 들어 이더넷 케이블 상에서 전송할 수 있느 형태로 캡슐화한다.

![image](https://user-images.githubusercontent.com/56383948/261845793-a14cac60-2fb5-4801-baf0-bb96b38d8c51.png)

- `Frame` : 전체 프레임의 정보를 제공한다.
- `Interface id` : 해당 프레임이 캡처된 네트워크 인터페이스의 ID와 이름이다.
- `Interface description` : 네트워크 인터페이스에 대한 설명이다.
- `Encapsulation type` : 캡슐화 유형으로, 해당 프레임이 어떤 유형의 프레임인지 나태낸다.

![image](https://user-images.githubusercontent.com/56383948/261845735-f14dd5d3-0e2b-40af-9abe-d7352f9b4d7e.png)


- `Ethernet ll, Src/Dst` : 이더넷 해더의 정보로, 소스와 목적지의 MAC 주소를 포함한다.
- `LG bit, IG bit` : MAC 주소 내의 특정 비트로, 주소의 유형(글로벌/로컬, 유니캐스트/멀티캐스트) 등을 나타낸다.
-  `Type` : 해당 유형의 프레임 내의 페이로드의 유형을 나타낸다.

<br/>

## 참고 자료

<br/>

- [페이로드사진](https://m.blog.naver.com/yoodh0713/221549142119)

<br/>
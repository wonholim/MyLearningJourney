# Compiler

---

- [x] 컴파일러의 정의
- [ ] 컴파일 과정
- [ ] 컴파일러 구조
- [ ] AST
- [ ] 결론

---

</br>

## 컴파일러의 정의

---

</br>

- 컴파일러는 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 **언어 번역 프로그램**을 의미한다.
- 본래의 문서를 `소스 코드` 또는 `원시 코드`라고 부르고, 출력된 문서를 `목적 코드`라고 한다.
  > 목적 코드는 주로 다른 프로그램이나 하드웨어가 처리하기에 용이한 형태로 출력되지만, 문서 파일이나, 그림 파일 등으로 옮기는 경우도 있다.

- 원시 코드에서 목적 코드로 옮기는 과정을 **컴파일**이라고 한다.

 우리가 컴파일러를 이해하려면, 과거의 역사로 돌아가야한다.
 초기 컴퓨터 프로그램들은 어셈블리어로 작성되었는데, CPU 아키텍처가 서로 달라, 똑같은 프로그램을 서로 다른 어셈블리어로 작성하는 비용이 커지면서, 고급 프로그래밍 언어의 필요성이 대두되었다.
 > intel과 AMD의 예시로 들어보면, 서로의 아키텍처가 다르기에 같은 프로그램이더라도, 다시 어셈블리어로 처리해야되는 불상사가 생기는 것이다.

```text
 컴퓨터 구조에 따라, 사용하는 기계어가 달라진다. 즉 컴퓨터 CPU마다 지원하는 오퍼레이션 타입과 개수는 모두 다르며, 
 레스터의 크기와 개수, 저장된 데이터 형의 표현도 각기 다르다.
 모든  범용 컴퓨터는 기본적으로 동일한 기능을 수행하지만, 기능을 어떤 과정을 거쳐 수행할지는 다르다.

 왜 다를까?
 제조사가 설계한 특정 CPU 아키텍처의 명령 집합은 기계어로 작성된 명령어들의 집합을 의미한다.
 각 명령어는 특정 연산을 수행하도록 설계되어있다.
 어셈블리어는 기계어 명령어에 대응하는 니모닉 이라고하는 읽기 쉬운 문자열이 사용된다.
 (ADD 니모닉은 덧셈 연산을 의미하는 것과 같다.)

 하나의 기계어 명령어에 대해, 여러 가지 표현 방식이나 니모닉이 있을 수 있을 수 있으며, 
 어셈블리어 명령어의 구조나 문법을 의미하는 통사론이 제조사나 컴파일러에서 다른 문법을 사용할 수 있다.
```

 > 이에 다양한 아키텍처에서 실행이 가능한 C언어가 생기게 되었고, 컴파일러를 통해 해당 CPU 아키텍처에 맞게 기계어로 번역을 할 수 있게 되었다.


</br>

## 컴파일 과정

---

</br>

</br>

## 컴파일러 구조

---

</br>

</br>

## AST

---

</br>

</br>

## 결론

---

</br>

</br>

## 출처

---

</br>

[parser](https://wan2.land/posts/2020/02/11/make-parser-1/), [파서에 대한 이해](https://edykim.com/ko/post/the-super-tiny-compiler/), [컴파일러](https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC)
